redis 和mysql 数据一致性：
1、更新的时候，先删除缓存，然后再更新数据库。
    读的时候，先读缓存；如果没有的话，就读数据库，同时将数据放入缓存，并返回响应。
    还是会出问题：
        ：数据发生了变更，先删除了缓存，然后去修改数据库。此时还没来得及修改，一个请求过来了，去读缓存，发现缓存空了，去读数据库，
        读到了准备修改前的旧数据，并且把旧数据放到了缓存。随后，数据变更程序完成了数据库的修改。那么完了，这个时候发生数据不一致了.,而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。
    解决：
        采用延时双删策略
            （1）先淘汰缓存
            （2）再写数据库
            （3）休眠1秒，再次淘汰缓存(1s的选择取决于业务逻辑的耗时)
        如果采用mysql的读写分离架构怎么办？
            ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。
            （1）请求A进行写操作，删除缓存
            （2）请求A将数据写入数据库了，
            （3）请求B查询缓存发现，缓存没有值
            （4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
            （5）请求B将旧值写入缓存
            （6）数据库完成主从同步，从库变为新值
            上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。
    采用这种同步淘汰策略，吞吐量降低怎么办？
        将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。
    新的问题：
        第二次删除,如果删除失败怎么办？
            这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：
            （1）请求A进行写操作，删除缓存
            （2）请求B查询发现缓存不存在
            （3）请求B去数据库查询得到旧值
            （4）请求B将旧值写入缓存
            （5）请求A将新值写入数据库
            （6）请求A试图去删除请求B写入对缓存值，结果失败了。
            ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。
2、先更新数据库，再删缓存
    问题：
        假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生
        （1）缓存刚好失效
        （2）请求A查询数据库，得一个旧值
        （3）请求B将新值写入数据库
        （4）请求B删除缓存
        （5）请求A将查到的旧值写入缓存
        ok，如果发生上述情况，确实是会发生脏数据。
    然而，发生这种情况的概率又有多少呢？这个原因有待考虑
         发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。
         可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现
   解决上述并发问题？
        首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。
   如果删缓存失败了怎么办？
        提供一个保障的重试机制；
      两种方式：
        1.
            （1）更新数据库数据；
            （2）缓存因为种种问题删除失败
            （3）将需要删除的key发送至消息队列
            （4）自己消费消息，获得需要删除的key
            （5）继续重试删除操作，直到成功
            然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，
            获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。
        2.
            （1）更新数据库数据
            （2）数据库会将操作信息写入binlog日志当中
            （3）订阅程序提取出所需要的数据以及key
            （4）另起一段非业务代码，获得该信息
            （5）尝试删除缓存操作，发现删除失败
            （6）将这些信息发送至消息队列
            （7）重新从消息队列中获得该数据，重试操作。
        订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。
        如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。
缓存设置的方式：
   两种：
       一种是永久存在，不设置过期时间，第二种是设置过期时间。
   2.1不设置过期时间
     当我们将缓存数据的key设置为永久存在时会存在数据同步和内存消耗逐渐增大的情况，解决方式如下：
    数据同步：
       禁止直接操作数据源,避免因数据源直接被改动而造成缓存数据不一致的问题
       如果有其他系统操作同一个数据源，这种情况肯定会产生数据不一致的情况。
       系统执行DML操作时，应该将缓存中对应的数据删除。用户下一次相关请求时直接从数据源中获取。
内存消耗：
   随着业务的增多，缓存数据必然会越来越多，所占用的内存也随之增多，系统的压力也会变大，这时一种方式是给key设置过期时间，但是过期时间长短不太好把握,
   这时我们可以通过设置redis最大内存来实现，并让Redis按照一定的规则淘汰不需要的缓存键，这种方式在redis只作为缓存使用时非常实用。
   LRU:（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”
    LFU:（Least Frequently Used）算法根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。
 具体实现方式:
      修改redis配置文件(redis.conf)中的maxmemory参数既可，限制Redis最大可用内存大小(单位字节)，
      当超出了这个限制时Redis会依据maxmemory-policy参数指定的策略来删除不需要的key直到Redis占用的内存小于指定内存。
      # In short... if you have slaves attached it is suggested that you set a lower
      # limit for maxmemory so that there is some free RAM on the system for slave
      # output buffers (but this is not needed if the policy is 'noeviction').
      # 内存设置
      # maxmemory <bytes>
      maxmemory 1024000000

      # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
      # is reached. You can select among five behaviors:
      #  删除算法
      # volatile-lru -> remove the key with an expire set using an LRU algorithm
      # allkeys-lru -> remove any key according to the LRU algorithm
      # volatile-random -> remove a random key with an expire set
      # allkeys-random -> remove a random key, any key
      # volatile-ttl -> remove the key with the nearest expire time (minor TTL)
      # noeviction -> don't expire at all, just return an error on write operations
      #
      #
      # The default is:
      # 默认的删除规则
      # maxmemory-policy volatile-lru

      # LRU and minimal TTL algorithms are not precise algorithms but approximated
       volatile-lru -> 使用LRU算法删除一个key(只对设置了过期时间的key有效)---------（使用LFU算法删除一个key(只对设置了过期时间的key有效)
       allkeys-lru -> 使用LRU算法删除一个key -------（使用LFU算法删除一个key）
       volatile-random -> 随机删除一个key(只对设置了过期时间的key有效)
       allkeys-random -> 随机删除一个key
       volatile-ttl -> 删除过期时间最近的一个key
       noeviction -> 不删除key，只返回错误
